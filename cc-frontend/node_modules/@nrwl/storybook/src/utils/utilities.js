"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTsSourceFile = exports.isTheFileAStory = exports.findStorybookAndBuildTargetsForStorybookAngularExecutors = exports.findStorybookAndBuildTargets = exports.dedupe = exports.findOrCreateConfig = exports.readCurrentWorkspaceStorybookVersionFromExecutor = exports.readCurrentWorkspaceStorybookVersionFromGenerator = exports.safeFileDelete = exports.isFramework = exports.Constants = void 0;
const devkit_1 = require("@nrwl/devkit");
const versions_1 = require("./versions");
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const find_nodes_1 = require("@nrwl/workspace/src/utilities/typescript/find-nodes");
const ts = require("typescript");
exports.Constants = {
    addonDependencies: ['@storybook/addons'],
    tsConfigExclusions: ['stories', '**/*.stories.ts'],
    pkgJsonScripts: {
        storybook: 'start-storybook -p 9001 -c .storybook',
    },
    jsonIndentLevel: 2,
    coreAddonPrefix: '@storybook/addon-',
    uiFrameworks: {
        angular: '@storybook/angular',
        react: '@storybook/react',
        html: '@storybook/html',
        'web-components': '@storybook/web-components',
        vue: '@storybook/vue',
        vue3: '@storybook/vue3',
        svelte: '@storybook/svelte',
        'react-native': '@storybook/react-native',
    },
};
function isFramework(type, schema) {
    if (type === 'angular' && schema.uiFramework === '@storybook/angular') {
        return true;
    }
    if (type === 'react' && schema.uiFramework === '@storybook/react') {
        return true;
    }
    if (type === 'html' && schema.uiFramework === '@storybook/html') {
        return true;
    }
    if (type === 'web-components' &&
        schema.uiFramework === '@storybook/web-components') {
        return true;
    }
    if (type === 'vue' && schema.uiFramework === '@storybook/vue') {
        return true;
    }
    if (type === 'vue3' && schema.uiFramework === '@storybook/vue3') {
        return true;
    }
    if (type === 'svelte' && schema.uiFramework === '@storybook/svelte') {
        return true;
    }
    if (type === 'react-native' &&
        schema.uiFramework === '@storybook/react-native') {
        return true;
    }
    return false;
}
exports.isFramework = isFramework;
function safeFileDelete(tree, path) {
    if (tree.exists(path)) {
        tree.delete(path);
        return true;
    }
    else {
        return false;
    }
}
exports.safeFileDelete = safeFileDelete;
function readCurrentWorkspaceStorybookVersionFromGenerator(tree) {
    const packageJsonContents = (0, devkit_1.readJson)(tree, 'package.json');
    return determineStorybookWorkspaceVersion(packageJsonContents);
}
exports.readCurrentWorkspaceStorybookVersionFromGenerator = readCurrentWorkspaceStorybookVersionFromGenerator;
function readCurrentWorkspaceStorybookVersionFromExecutor() {
    const packageJsonContents = (0, devkit_1.readJsonFile)('package.json');
    return determineStorybookWorkspaceVersion(packageJsonContents);
}
exports.readCurrentWorkspaceStorybookVersionFromExecutor = readCurrentWorkspaceStorybookVersionFromExecutor;
function determineStorybookWorkspaceVersion(packageJsonContents) {
    let workspaceStorybookVersion = versions_1.storybookVersion;
    if (packageJsonContents && packageJsonContents['devDependencies']) {
        if (packageJsonContents['devDependencies']['@storybook/angular']) {
            workspaceStorybookVersion =
                packageJsonContents['devDependencies']['@storybook/angular'];
        }
        if (packageJsonContents['devDependencies']['@storybook/react']) {
            workspaceStorybookVersion =
                packageJsonContents['devDependencies']['@storybook/react'];
        }
        if (packageJsonContents['devDependencies']['@storybook/core']) {
            workspaceStorybookVersion =
                packageJsonContents['devDependencies']['@storybook/core'];
        }
        if (packageJsonContents['devDependencies']['@storybook/react-native']) {
            workspaceStorybookVersion =
                packageJsonContents['devDependencies']['@storybook/react-native'];
        }
    }
    if (packageJsonContents && packageJsonContents['dependencies']) {
        if (packageJsonContents['dependencies']['@storybook/angular']) {
            workspaceStorybookVersion =
                packageJsonContents['dependencies']['@storybook/angular'];
        }
        if (packageJsonContents['dependencies']['@storybook/react']) {
            workspaceStorybookVersion =
                packageJsonContents['dependencies']['@storybook/react'];
        }
        if (packageJsonContents['dependencies']['@storybook/core']) {
            workspaceStorybookVersion =
                packageJsonContents['dependencies']['@storybook/core'];
        }
        if (packageJsonContents['dependencies']['@storybook/react-native']) {
            workspaceStorybookVersion =
                packageJsonContents['dependencies']['@storybook/react-native'];
        }
    }
    return workspaceStorybookVersion;
}
function findOrCreateConfig(config, context) {
    if ((config === null || config === void 0 ? void 0 : config.configFolder) && (0, fs_1.statSync)(config.configFolder).isDirectory()) {
        return config.configFolder;
    }
    else if ((0, fs_1.statSync)(config.configPath).isFile() &&
        (0, fs_1.statSync)(config.pluginPath).isFile() &&
        (0, fs_1.statSync)(config.srcRoot).isFile()) {
        return createStorybookConfig(config.configPath, config.pluginPath, config.srcRoot);
    }
    else {
        const sourceRoot = context.workspace.projects[context.projectName].root;
        if ((0, fs_1.statSync)((0, path_1.join)(context.root, sourceRoot, '.storybook')).isDirectory()) {
            return (0, path_1.join)(context.root, sourceRoot, '.storybook');
        }
    }
    throw new Error('No configuration settings');
}
exports.findOrCreateConfig = findOrCreateConfig;
function createStorybookConfig(configPath, pluginPath, srcRoot) {
    const tmpDir = (0, os_1.tmpdir)();
    const tmpFolder = `${tmpDir}${path_1.sep}`;
    (0, fs_1.mkdtempSync)(tmpFolder);
    (0, fs_1.copyFileSync)(configPath, `${tmpFolder}/${(0, path_1.basename)(configPath)}`, fs_1.constants.COPYFILE_EXCL);
    (0, fs_1.copyFileSync)(pluginPath, `${tmpFolder}/${(0, path_1.basename)(pluginPath)}`, fs_1.constants.COPYFILE_EXCL);
    (0, fs_1.copyFileSync)(srcRoot, `${tmpFolder}/${(0, path_1.basename)(srcRoot)}`, fs_1.constants.COPYFILE_EXCL);
    return tmpFolder;
}
function dedupe(arr) {
    return Array.from(new Set(arr));
}
exports.dedupe = dedupe;
/**
 * This function is only used for ANGULAR projects.
 * And it is used for the "old" Storybook/Angular setup,
 * where the Nx executor is used.
 *
 * At the moment, it's used by the migrator to set projectBuildConfig
 * and it is also used by the change-storybook-targets generator/migrator
 */
function findStorybookAndBuildTargets(targets) {
    const returnObject = {};
    Object.entries(targets).forEach(([target, targetConfig]) => {
        if (targetConfig.executor === '@nrwl/storybook:storybook') {
            returnObject.storybookTarget = target;
        }
        if (targetConfig.executor === '@nrwl/storybook:build') {
            returnObject.storybookBuildTarget = target;
        }
        /**
         * Not looking for '@nrwl/angular:ng-packagr-lite', only
         * looking for '@angular-devkit/build-angular:browser'
         * because the '@nrwl/angular:ng-packagr-lite' executor
         * does not support styles and extra options, so the user
         * will be forced to switch to build-storybook to add extra options.
         *
         * So we might as well use the build-storybook by default to
         * avoid any errors.
         */
        if (targetConfig.executor === '@angular-devkit/build-angular:browser') {
            returnObject.buildTarget = target;
        }
    });
    return returnObject;
}
exports.findStorybookAndBuildTargets = findStorybookAndBuildTargets;
/**
 * This function is not used at the moment.
 *
 * However, it may be valuable to create this here, in order to avoid
 * any confusion in the future.
 *
 */
function findStorybookAndBuildTargetsForStorybookAngularExecutors(targets) {
    const returnObject = {};
    Object.entries(targets).forEach(([target, targetConfig]) => {
        if (targetConfig.executor === '@storybook/angular:start-storybook') {
            returnObject.storybookTarget = target;
        }
        if (targetConfig.executor === '@storybook/angular:build-storybook') {
            returnObject.storybookBuildTarget = target;
        }
        /**
         * Not looking for '@nrwl/angular:ng-packagr-lite', only
         * looking for '@angular-devkit/build-angular:browser'
         * because the '@nrwl/angular:ng-packagr-lite' executor
         * does not support styles and extra options, so the user
         * will be forced to switch to build-storybook to add extra options.
         *
         * So we might as well use the build-storybook by default to
         * avoid any errors.
         */
        if (targetConfig.executor === '@angular-devkit/build-angular:browser') {
            returnObject.buildTarget = target;
        }
    });
    return returnObject;
}
exports.findStorybookAndBuildTargetsForStorybookAngularExecutors = findStorybookAndBuildTargetsForStorybookAngularExecutors;
function isTheFileAStory(tree, path) {
    const ext = path.slice(path.lastIndexOf('.'));
    let fileIsStory = false;
    if (ext === '.tsx' || ext === '.ts') {
        const file = getTsSourceFile(tree, path);
        const importArray = (0, find_nodes_1.findNodes)(file, [ts.SyntaxKind.ImportDeclaration]);
        let nodeContainsStorybookImport = false;
        let nodeContainsStoryImport = false;
        importArray.forEach((importNode) => {
            const importPath = (0, find_nodes_1.findNodes)(importNode, [ts.SyntaxKind.StringLiteral]);
            importPath.forEach((importPath) => {
                var _a;
                if ((_a = importPath.getText()) === null || _a === void 0 ? void 0 : _a.includes('@storybook/')) {
                    nodeContainsStorybookImport = true;
                }
            });
            const importSpecifiers = (0, find_nodes_1.findNodes)(importNode, [
                ts.SyntaxKind.ImportSpecifier,
            ]);
            importSpecifiers.forEach((importSpecifier) => {
                if (importSpecifier.getText() === 'Story' ||
                    importSpecifier.getText() === 'storiesOf' ||
                    importSpecifier.getText() === 'ComponentStory') {
                    nodeContainsStoryImport = true;
                }
            });
            // We place this check within the loop, because we want the
            // import combination of Story from @storybook/*
            if (nodeContainsStorybookImport && nodeContainsStoryImport) {
                fileIsStory = true;
            }
        });
    }
    else {
        fileIsStory =
            (path.endsWith('.js') && path.endsWith('.stories.js')) ||
                (path.endsWith('.jsx') && path.endsWith('.stories.jsx'));
    }
    return fileIsStory;
}
exports.isTheFileAStory = isTheFileAStory;
function getTsSourceFile(host, path) {
    const buffer = host.read(path);
    if (!buffer) {
        throw new Error(`Could not read TS file (${path}).`);
    }
    const content = buffer.toString();
    const source = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);
    return source;
}
exports.getTsSourceFile = getTsSourceFile;
//# sourceMappingURL=utilities.js.map